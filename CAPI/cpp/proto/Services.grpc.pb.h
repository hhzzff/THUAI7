// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: Services.proto
#ifndef GRPC_Services_2eproto__INCLUDED
#define GRPC_Services_2eproto__INCLUDED

#include "Services.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace protobuf
{

    class AvailableService final
    {
    public:
        static constexpr char const* service_full_name()
        {
            return "protobuf.AvailableService";
        }
        class StubInterface
        {
        public:
            virtual ~StubInterface()
            {
            }
            virtual ::grpc::Status TryConnection(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncTryConnection(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncTryConnectionRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncTryConnection(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncTryConnectionRaw(context, request, cq));
            }
            // 游戏开局调用一次的服务
            std::unique_ptr<::grpc::ClientReaderInterface<::protobuf::MessageToClient>> AddPlayer(::grpc::ClientContext* context, const ::protobuf::PlayerMsg& request)
            {
                return std::unique_ptr<::grpc::ClientReaderInterface<::protobuf::MessageToClient>>(AddPlayerRaw(context, request));
            }
            std::unique_ptr<::grpc::ClientAsyncReaderInterface<::protobuf::MessageToClient>> AsyncAddPlayer(::grpc::ClientContext* context, const ::protobuf::PlayerMsg& request, ::grpc::CompletionQueue* cq, void* tag)
            {
                return std::unique_ptr<::grpc::ClientAsyncReaderInterface<::protobuf::MessageToClient>>(AsyncAddPlayerRaw(context, request, cq, tag));
            }
            std::unique_ptr<::grpc::ClientAsyncReaderInterface<::protobuf::MessageToClient>> PrepareAsyncAddPlayer(::grpc::ClientContext* context, const ::protobuf::PlayerMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncReaderInterface<::protobuf::MessageToClient>>(PrepareAsyncAddPlayerRaw(context, request, cq));
            }
            // 连接上后等待游戏开始，server会定时通过该服务向所有client发送消息
            virtual ::grpc::Status GetMap(::grpc::ClientContext* context, const ::protobuf::NullRequest& request, ::protobuf::MessageOfMap* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::MessageOfMap>> AsyncGetMap(::grpc::ClientContext* context, const ::protobuf::NullRequest& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::MessageOfMap>>(AsyncGetMapRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::MessageOfMap>> PrepareAsyncGetMap(::grpc::ClientContext* context, const ::protobuf::NullRequest& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::MessageOfMap>>(PrepareAsyncGetMapRaw(context, request, cq));
            }
            // 游戏过程中玩家执行操作的服务
            // 船
            virtual ::grpc::Status Move(::grpc::ClientContext* context, const ::protobuf::MoveMsg& request, ::protobuf::MoveRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::MoveRes>> AsyncMove(::grpc::ClientContext* context, const ::protobuf::MoveMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::MoveRes>>(AsyncMoveRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::MoveRes>> PrepareAsyncMove(::grpc::ClientContext* context, const ::protobuf::MoveMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::MoveRes>>(PrepareAsyncMoveRaw(context, request, cq));
            }
            // 移动
            virtual ::grpc::Status Recover(::grpc::ClientContext* context, const ::protobuf::RecoverMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncRecover(::grpc::ClientContext* context, const ::protobuf::RecoverMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncRecoverRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncRecover(::grpc::ClientContext* context, const ::protobuf::RecoverMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncRecoverRaw(context, request, cq));
            }
            // 回复
            virtual ::grpc::Status Produce(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncProduce(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncProduceRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncProduce(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncProduceRaw(context, request, cq));
            }
            // 开采
            virtual ::grpc::Status Rebuild(::grpc::ClientContext* context, const ::protobuf::ConstructMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncRebuild(::grpc::ClientContext* context, const ::protobuf::ConstructMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncRebuildRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncRebuild(::grpc::ClientContext* context, const ::protobuf::ConstructMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncRebuildRaw(context, request, cq));
            }
            // 给建筑回血
            virtual ::grpc::Status Construct(::grpc::ClientContext* context, const ::protobuf::ConstructMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncConstruct(::grpc::ClientContext* context, const ::protobuf::ConstructMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncConstructRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncConstruct(::grpc::ClientContext* context, const ::protobuf::ConstructMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncConstructRaw(context, request, cq));
            }
            // 修建建筑
            virtual ::grpc::Status RepairHome(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncRepairHome(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncRepairHomeRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncRepairHome(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncRepairHomeRaw(context, request, cq));
            }
            // 修理大本营
            virtual ::grpc::Status RepairWormhole(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncRepairWormhole(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncRepairWormholeRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncRepairWormhole(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncRepairWormholeRaw(context, request, cq));
            }
            // 修理虫洞
            virtual ::grpc::Status Attack(::grpc::ClientContext* context, const ::protobuf::AttackMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncAttack(::grpc::ClientContext* context, const ::protobuf::AttackMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncAttackRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncAttack(::grpc::ClientContext* context, const ::protobuf::AttackMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncAttackRaw(context, request, cq));
            }
            // 攻击
            virtual ::grpc::Status Send(::grpc::ClientContext* context, const ::protobuf::SendMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncSend(::grpc::ClientContext* context, const ::protobuf::SendMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncSendRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncSend(::grpc::ClientContext* context, const ::protobuf::SendMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncSendRaw(context, request, cq));
            }
            // 传递信息
            // 大本营
            virtual ::grpc::Status InstallModule(::grpc::ClientContext* context, const ::protobuf::InstallMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncInstallModule(::grpc::ClientContext* context, const ::protobuf::InstallMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncInstallModuleRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncInstallModule(::grpc::ClientContext* context, const ::protobuf::InstallMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncInstallModuleRaw(context, request, cq));
            }
            virtual ::grpc::Status Recycle(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncRecycle(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncRecycleRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncRecycle(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncRecycleRaw(context, request, cq));
            }
            virtual ::grpc::Status BuildShip(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncBuildShip(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncBuildShipRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncBuildShip(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncBuildShipRaw(context, request, cq));
            }
            virtual ::grpc::Status BuildShipRID(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg& request, ::protobuf::BuildShipRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BuildShipRes>> AsyncBuildShipRID(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BuildShipRes>>(AsyncBuildShipRIDRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BuildShipRes>> PrepareAsyncBuildShipRID(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BuildShipRes>>(PrepareAsyncBuildShipRIDRaw(context, request, cq));
            }
            virtual ::grpc::Status EndAllAction(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) = 0;
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> AsyncEndAllAction(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(AsyncEndAllActionRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>> PrepareAsyncEndAllAction(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>>(PrepareAsyncEndAllActionRaw(context, request, cq));
            }
            // 结束所有动作
            class async_interface
            {
            public:
                virtual ~async_interface()
                {
                }
                virtual void TryConnection(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void TryConnection(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                // 游戏开局调用一次的服务
                virtual void AddPlayer(::grpc::ClientContext* context, const ::protobuf::PlayerMsg* request, ::grpc::ClientReadReactor<::protobuf::MessageToClient>* reactor) = 0;
                // 连接上后等待游戏开始，server会定时通过该服务向所有client发送消息
                virtual void GetMap(::grpc::ClientContext* context, const ::protobuf::NullRequest* request, ::protobuf::MessageOfMap* response, std::function<void(::grpc::Status)>) = 0;
                virtual void GetMap(::grpc::ClientContext* context, const ::protobuf::NullRequest* request, ::protobuf::MessageOfMap* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                // 游戏过程中玩家执行操作的服务
                // 船
                virtual void Move(::grpc::ClientContext* context, const ::protobuf::MoveMsg* request, ::protobuf::MoveRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void Move(::grpc::ClientContext* context, const ::protobuf::MoveMsg* request, ::protobuf::MoveRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                // 移动
                virtual void Recover(::grpc::ClientContext* context, const ::protobuf::RecoverMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void Recover(::grpc::ClientContext* context, const ::protobuf::RecoverMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                // 回复
                virtual void Produce(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void Produce(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                // 开采
                virtual void Rebuild(::grpc::ClientContext* context, const ::protobuf::ConstructMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void Rebuild(::grpc::ClientContext* context, const ::protobuf::ConstructMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                // 给建筑回血
                virtual void Construct(::grpc::ClientContext* context, const ::protobuf::ConstructMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void Construct(::grpc::ClientContext* context, const ::protobuf::ConstructMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                // 修建建筑
                virtual void RepairHome(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void RepairHome(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                // 修理大本营
                virtual void RepairWormhole(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void RepairWormhole(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                // 修理虫洞
                virtual void Attack(::grpc::ClientContext* context, const ::protobuf::AttackMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void Attack(::grpc::ClientContext* context, const ::protobuf::AttackMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                // 攻击
                virtual void Send(::grpc::ClientContext* context, const ::protobuf::SendMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void Send(::grpc::ClientContext* context, const ::protobuf::SendMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                // 传递信息
                // 大本营
                virtual void InstallModule(::grpc::ClientContext* context, const ::protobuf::InstallMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void InstallModule(::grpc::ClientContext* context, const ::protobuf::InstallMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                virtual void Recycle(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void Recycle(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                virtual void BuildShip(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void BuildShip(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                virtual void BuildShipRID(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg* request, ::protobuf::BuildShipRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void BuildShipRID(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg* request, ::protobuf::BuildShipRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                virtual void EndAllAction(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) = 0;
                virtual void EndAllAction(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
                // 结束所有动作
            };
            typedef class async_interface experimental_async_interface;
            virtual class async_interface* async()
            {
                return nullptr;
            }
            class async_interface* experimental_async()
            {
                return async();
            }

        private:
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncTryConnectionRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncTryConnectionRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientReaderInterface<::protobuf::MessageToClient>* AddPlayerRaw(::grpc::ClientContext* context, const ::protobuf::PlayerMsg& request) = 0;
            virtual ::grpc::ClientAsyncReaderInterface<::protobuf::MessageToClient>* AsyncAddPlayerRaw(::grpc::ClientContext* context, const ::protobuf::PlayerMsg& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
            virtual ::grpc::ClientAsyncReaderInterface<::protobuf::MessageToClient>* PrepareAsyncAddPlayerRaw(::grpc::ClientContext* context, const ::protobuf::PlayerMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::MessageOfMap>* AsyncGetMapRaw(::grpc::ClientContext* context, const ::protobuf::NullRequest& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::MessageOfMap>* PrepareAsyncGetMapRaw(::grpc::ClientContext* context, const ::protobuf::NullRequest& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::MoveRes>* AsyncMoveRaw(::grpc::ClientContext* context, const ::protobuf::MoveMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::MoveRes>* PrepareAsyncMoveRaw(::grpc::ClientContext* context, const ::protobuf::MoveMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncRecoverRaw(::grpc::ClientContext* context, const ::protobuf::RecoverMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncRecoverRaw(::grpc::ClientContext* context, const ::protobuf::RecoverMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncProduceRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncProduceRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncRebuildRaw(::grpc::ClientContext* context, const ::protobuf::ConstructMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncRebuildRaw(::grpc::ClientContext* context, const ::protobuf::ConstructMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncConstructRaw(::grpc::ClientContext* context, const ::protobuf::ConstructMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncConstructRaw(::grpc::ClientContext* context, const ::protobuf::ConstructMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncRepairHomeRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncRepairHomeRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncRepairWormholeRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncRepairWormholeRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncAttackRaw(::grpc::ClientContext* context, const ::protobuf::AttackMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncAttackRaw(::grpc::ClientContext* context, const ::protobuf::AttackMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncSendRaw(::grpc::ClientContext* context, const ::protobuf::SendMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncSendRaw(::grpc::ClientContext* context, const ::protobuf::SendMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncInstallModuleRaw(::grpc::ClientContext* context, const ::protobuf::InstallMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncInstallModuleRaw(::grpc::ClientContext* context, const ::protobuf::InstallMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncRecycleRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncRecycleRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncBuildShipRaw(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncBuildShipRaw(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BuildShipRes>* AsyncBuildShipRIDRaw(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BuildShipRes>* PrepareAsyncBuildShipRIDRaw(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* AsyncEndAllActionRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
            virtual ::grpc::ClientAsyncResponseReaderInterface<::protobuf::BoolRes>* PrepareAsyncEndAllActionRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) = 0;
        };
        class Stub final : public StubInterface
        {
        public:
            Stub(const std::shared_ptr<::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
            ::grpc::Status TryConnection(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncTryConnection(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncTryConnectionRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncTryConnection(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncTryConnectionRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientReader<::protobuf::MessageToClient>> AddPlayer(::grpc::ClientContext* context, const ::protobuf::PlayerMsg& request)
            {
                return std::unique_ptr<::grpc::ClientReader<::protobuf::MessageToClient>>(AddPlayerRaw(context, request));
            }
            std::unique_ptr<::grpc::ClientAsyncReader<::protobuf::MessageToClient>> AsyncAddPlayer(::grpc::ClientContext* context, const ::protobuf::PlayerMsg& request, ::grpc::CompletionQueue* cq, void* tag)
            {
                return std::unique_ptr<::grpc::ClientAsyncReader<::protobuf::MessageToClient>>(AsyncAddPlayerRaw(context, request, cq, tag));
            }
            std::unique_ptr<::grpc::ClientAsyncReader<::protobuf::MessageToClient>> PrepareAsyncAddPlayer(::grpc::ClientContext* context, const ::protobuf::PlayerMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncReader<::protobuf::MessageToClient>>(PrepareAsyncAddPlayerRaw(context, request, cq));
            }
            ::grpc::Status GetMap(::grpc::ClientContext* context, const ::protobuf::NullRequest& request, ::protobuf::MessageOfMap* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::MessageOfMap>> AsyncGetMap(::grpc::ClientContext* context, const ::protobuf::NullRequest& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::MessageOfMap>>(AsyncGetMapRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::MessageOfMap>> PrepareAsyncGetMap(::grpc::ClientContext* context, const ::protobuf::NullRequest& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::MessageOfMap>>(PrepareAsyncGetMapRaw(context, request, cq));
            }
            ::grpc::Status Move(::grpc::ClientContext* context, const ::protobuf::MoveMsg& request, ::protobuf::MoveRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::MoveRes>> AsyncMove(::grpc::ClientContext* context, const ::protobuf::MoveMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::MoveRes>>(AsyncMoveRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::MoveRes>> PrepareAsyncMove(::grpc::ClientContext* context, const ::protobuf::MoveMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::MoveRes>>(PrepareAsyncMoveRaw(context, request, cq));
            }
            ::grpc::Status Recover(::grpc::ClientContext* context, const ::protobuf::RecoverMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncRecover(::grpc::ClientContext* context, const ::protobuf::RecoverMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncRecoverRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncRecover(::grpc::ClientContext* context, const ::protobuf::RecoverMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncRecoverRaw(context, request, cq));
            }
            ::grpc::Status Produce(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncProduce(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncProduceRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncProduce(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncProduceRaw(context, request, cq));
            }
            ::grpc::Status Rebuild(::grpc::ClientContext* context, const ::protobuf::ConstructMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncRebuild(::grpc::ClientContext* context, const ::protobuf::ConstructMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncRebuildRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncRebuild(::grpc::ClientContext* context, const ::protobuf::ConstructMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncRebuildRaw(context, request, cq));
            }
            ::grpc::Status Construct(::grpc::ClientContext* context, const ::protobuf::ConstructMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncConstruct(::grpc::ClientContext* context, const ::protobuf::ConstructMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncConstructRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncConstruct(::grpc::ClientContext* context, const ::protobuf::ConstructMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncConstructRaw(context, request, cq));
            }
            ::grpc::Status RepairHome(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncRepairHome(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncRepairHomeRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncRepairHome(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncRepairHomeRaw(context, request, cq));
            }
            ::grpc::Status RepairWormhole(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncRepairWormhole(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncRepairWormholeRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncRepairWormhole(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncRepairWormholeRaw(context, request, cq));
            }
            ::grpc::Status Attack(::grpc::ClientContext* context, const ::protobuf::AttackMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncAttack(::grpc::ClientContext* context, const ::protobuf::AttackMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncAttackRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncAttack(::grpc::ClientContext* context, const ::protobuf::AttackMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncAttackRaw(context, request, cq));
            }
            ::grpc::Status Send(::grpc::ClientContext* context, const ::protobuf::SendMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncSend(::grpc::ClientContext* context, const ::protobuf::SendMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncSendRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncSend(::grpc::ClientContext* context, const ::protobuf::SendMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncSendRaw(context, request, cq));
            }
            ::grpc::Status InstallModule(::grpc::ClientContext* context, const ::protobuf::InstallMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncInstallModule(::grpc::ClientContext* context, const ::protobuf::InstallMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncInstallModuleRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncInstallModule(::grpc::ClientContext* context, const ::protobuf::InstallMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncInstallModuleRaw(context, request, cq));
            }
            ::grpc::Status Recycle(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncRecycle(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncRecycleRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncRecycle(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncRecycleRaw(context, request, cq));
            }
            ::grpc::Status BuildShip(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncBuildShip(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncBuildShipRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncBuildShip(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncBuildShipRaw(context, request, cq));
            }
            ::grpc::Status BuildShipRID(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg& request, ::protobuf::BuildShipRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BuildShipRes>> AsyncBuildShipRID(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BuildShipRes>>(AsyncBuildShipRIDRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BuildShipRes>> PrepareAsyncBuildShipRID(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BuildShipRes>>(PrepareAsyncBuildShipRIDRaw(context, request, cq));
            }
            ::grpc::Status EndAllAction(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::protobuf::BoolRes* response) override;
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> AsyncEndAllAction(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(AsyncEndAllActionRaw(context, request, cq));
            }
            std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>> PrepareAsyncEndAllAction(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq)
            {
                return std::unique_ptr<::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>>(PrepareAsyncEndAllActionRaw(context, request, cq));
            }
            class async final :
                public StubInterface::async_interface
            {
            public:
                void TryConnection(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void TryConnection(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void AddPlayer(::grpc::ClientContext* context, const ::protobuf::PlayerMsg* request, ::grpc::ClientReadReactor<::protobuf::MessageToClient>* reactor) override;
                void GetMap(::grpc::ClientContext* context, const ::protobuf::NullRequest* request, ::protobuf::MessageOfMap* response, std::function<void(::grpc::Status)>) override;
                void GetMap(::grpc::ClientContext* context, const ::protobuf::NullRequest* request, ::protobuf::MessageOfMap* response, ::grpc::ClientUnaryReactor* reactor) override;
                void Move(::grpc::ClientContext* context, const ::protobuf::MoveMsg* request, ::protobuf::MoveRes* response, std::function<void(::grpc::Status)>) override;
                void Move(::grpc::ClientContext* context, const ::protobuf::MoveMsg* request, ::protobuf::MoveRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void Recover(::grpc::ClientContext* context, const ::protobuf::RecoverMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void Recover(::grpc::ClientContext* context, const ::protobuf::RecoverMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void Produce(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void Produce(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void Rebuild(::grpc::ClientContext* context, const ::protobuf::ConstructMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void Rebuild(::grpc::ClientContext* context, const ::protobuf::ConstructMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void Construct(::grpc::ClientContext* context, const ::protobuf::ConstructMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void Construct(::grpc::ClientContext* context, const ::protobuf::ConstructMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void RepairHome(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void RepairHome(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void RepairWormhole(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void RepairWormhole(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void Attack(::grpc::ClientContext* context, const ::protobuf::AttackMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void Attack(::grpc::ClientContext* context, const ::protobuf::AttackMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void Send(::grpc::ClientContext* context, const ::protobuf::SendMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void Send(::grpc::ClientContext* context, const ::protobuf::SendMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void InstallModule(::grpc::ClientContext* context, const ::protobuf::InstallMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void InstallModule(::grpc::ClientContext* context, const ::protobuf::InstallMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void Recycle(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void Recycle(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void BuildShip(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void BuildShip(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void BuildShipRID(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg* request, ::protobuf::BuildShipRes* response, std::function<void(::grpc::Status)>) override;
                void BuildShipRID(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg* request, ::protobuf::BuildShipRes* response, ::grpc::ClientUnaryReactor* reactor) override;
                void EndAllAction(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, std::function<void(::grpc::Status)>) override;
                void EndAllAction(::grpc::ClientContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response, ::grpc::ClientUnaryReactor* reactor) override;

            private:
                friend class Stub;
                explicit async(Stub* stub) :
                    stub_(stub)
                {
                }
                Stub* stub()
                {
                    return stub_;
                }
                Stub* stub_;
            };
            class async* async() override
            {
                return &async_stub_;
            }

        private:
            std::shared_ptr<::grpc::ChannelInterface> channel_;
            class async async_stub_
            {
                this
            };
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncTryConnectionRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncTryConnectionRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientReader<::protobuf::MessageToClient>* AddPlayerRaw(::grpc::ClientContext* context, const ::protobuf::PlayerMsg& request) override;
            ::grpc::ClientAsyncReader<::protobuf::MessageToClient>* AsyncAddPlayerRaw(::grpc::ClientContext* context, const ::protobuf::PlayerMsg& request, ::grpc::CompletionQueue* cq, void* tag) override;
            ::grpc::ClientAsyncReader<::protobuf::MessageToClient>* PrepareAsyncAddPlayerRaw(::grpc::ClientContext* context, const ::protobuf::PlayerMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::MessageOfMap>* AsyncGetMapRaw(::grpc::ClientContext* context, const ::protobuf::NullRequest& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::MessageOfMap>* PrepareAsyncGetMapRaw(::grpc::ClientContext* context, const ::protobuf::NullRequest& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::MoveRes>* AsyncMoveRaw(::grpc::ClientContext* context, const ::protobuf::MoveMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::MoveRes>* PrepareAsyncMoveRaw(::grpc::ClientContext* context, const ::protobuf::MoveMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncRecoverRaw(::grpc::ClientContext* context, const ::protobuf::RecoverMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncRecoverRaw(::grpc::ClientContext* context, const ::protobuf::RecoverMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncProduceRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncProduceRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncRebuildRaw(::grpc::ClientContext* context, const ::protobuf::ConstructMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncRebuildRaw(::grpc::ClientContext* context, const ::protobuf::ConstructMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncConstructRaw(::grpc::ClientContext* context, const ::protobuf::ConstructMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncConstructRaw(::grpc::ClientContext* context, const ::protobuf::ConstructMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncRepairHomeRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncRepairHomeRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncRepairWormholeRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncRepairWormholeRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncAttackRaw(::grpc::ClientContext* context, const ::protobuf::AttackMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncAttackRaw(::grpc::ClientContext* context, const ::protobuf::AttackMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncSendRaw(::grpc::ClientContext* context, const ::protobuf::SendMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncSendRaw(::grpc::ClientContext* context, const ::protobuf::SendMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncInstallModuleRaw(::grpc::ClientContext* context, const ::protobuf::InstallMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncInstallModuleRaw(::grpc::ClientContext* context, const ::protobuf::InstallMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncRecycleRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncRecycleRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncBuildShipRaw(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncBuildShipRaw(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BuildShipRes>* AsyncBuildShipRIDRaw(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BuildShipRes>* PrepareAsyncBuildShipRIDRaw(::grpc::ClientContext* context, const ::protobuf::BuildShipMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* AsyncEndAllActionRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            ::grpc::ClientAsyncResponseReader<::protobuf::BoolRes>* PrepareAsyncEndAllActionRaw(::grpc::ClientContext* context, const ::protobuf::IDMsg& request, ::grpc::CompletionQueue* cq) override;
            const ::grpc::internal::RpcMethod rpcmethod_TryConnection_;
            const ::grpc::internal::RpcMethod rpcmethod_AddPlayer_;
            const ::grpc::internal::RpcMethod rpcmethod_GetMap_;
            const ::grpc::internal::RpcMethod rpcmethod_Move_;
            const ::grpc::internal::RpcMethod rpcmethod_Recover_;
            const ::grpc::internal::RpcMethod rpcmethod_Produce_;
            const ::grpc::internal::RpcMethod rpcmethod_Rebuild_;
            const ::grpc::internal::RpcMethod rpcmethod_Construct_;
            const ::grpc::internal::RpcMethod rpcmethod_RepairHome_;
            const ::grpc::internal::RpcMethod rpcmethod_RepairWormhole_;
            const ::grpc::internal::RpcMethod rpcmethod_Attack_;
            const ::grpc::internal::RpcMethod rpcmethod_Send_;
            const ::grpc::internal::RpcMethod rpcmethod_InstallModule_;
            const ::grpc::internal::RpcMethod rpcmethod_Recycle_;
            const ::grpc::internal::RpcMethod rpcmethod_BuildShip_;
            const ::grpc::internal::RpcMethod rpcmethod_BuildShipRID_;
            const ::grpc::internal::RpcMethod rpcmethod_EndAllAction_;
        };
        static std::unique_ptr<Stub> NewStub(const std::shared_ptr<::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

        class Service : public ::grpc::Service
        {
        public:
            Service();
            virtual ~Service();
            virtual ::grpc::Status TryConnection(::grpc::ServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response);
            // 游戏开局调用一次的服务
            virtual ::grpc::Status AddPlayer(::grpc::ServerContext* context, const ::protobuf::PlayerMsg* request, ::grpc::ServerWriter<::protobuf::MessageToClient>* writer);
            // 连接上后等待游戏开始，server会定时通过该服务向所有client发送消息
            virtual ::grpc::Status GetMap(::grpc::ServerContext* context, const ::protobuf::NullRequest* request, ::protobuf::MessageOfMap* response);
            // 游戏过程中玩家执行操作的服务
            // 船
            virtual ::grpc::Status Move(::grpc::ServerContext* context, const ::protobuf::MoveMsg* request, ::protobuf::MoveRes* response);
            // 移动
            virtual ::grpc::Status Recover(::grpc::ServerContext* context, const ::protobuf::RecoverMsg* request, ::protobuf::BoolRes* response);
            // 回复
            virtual ::grpc::Status Produce(::grpc::ServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response);
            // 开采
            virtual ::grpc::Status Rebuild(::grpc::ServerContext* context, const ::protobuf::ConstructMsg* request, ::protobuf::BoolRes* response);
            // 给建筑回血
            virtual ::grpc::Status Construct(::grpc::ServerContext* context, const ::protobuf::ConstructMsg* request, ::protobuf::BoolRes* response);
            // 修建建筑
            virtual ::grpc::Status RepairHome(::grpc::ServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response);
            // 修理大本营
            virtual ::grpc::Status RepairWormhole(::grpc::ServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response);
            // 修理虫洞
            virtual ::grpc::Status Attack(::grpc::ServerContext* context, const ::protobuf::AttackMsg* request, ::protobuf::BoolRes* response);
            // 攻击
            virtual ::grpc::Status Send(::grpc::ServerContext* context, const ::protobuf::SendMsg* request, ::protobuf::BoolRes* response);
            // 传递信息
            // 大本营
            virtual ::grpc::Status InstallModule(::grpc::ServerContext* context, const ::protobuf::InstallMsg* request, ::protobuf::BoolRes* response);
            virtual ::grpc::Status Recycle(::grpc::ServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response);
            virtual ::grpc::Status BuildShip(::grpc::ServerContext* context, const ::protobuf::BuildShipMsg* request, ::protobuf::BoolRes* response);
            virtual ::grpc::Status BuildShipRID(::grpc::ServerContext* context, const ::protobuf::BuildShipMsg* request, ::protobuf::BuildShipRes* response);
            virtual ::grpc::Status EndAllAction(::grpc::ServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response);
            // 结束所有动作
        };
        template<class BaseClass>
        class WithAsyncMethod_TryConnection : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_TryConnection()
            {
                ::grpc::Service::MarkMethodAsync(0);
            }
            ~WithAsyncMethod_TryConnection() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status TryConnection(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestTryConnection(::grpc::ServerContext* context, ::protobuf::IDMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_AddPlayer : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_AddPlayer()
            {
                ::grpc::Service::MarkMethodAsync(1);
            }
            ~WithAsyncMethod_AddPlayer() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status AddPlayer(::grpc::ServerContext* /*context*/, const ::protobuf::PlayerMsg* /*request*/, ::grpc::ServerWriter<::protobuf::MessageToClient>* /*writer*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestAddPlayer(::grpc::ServerContext* context, ::protobuf::PlayerMsg* request, ::grpc::ServerAsyncWriter<::protobuf::MessageToClient>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_GetMap : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_GetMap()
            {
                ::grpc::Service::MarkMethodAsync(2);
            }
            ~WithAsyncMethod_GetMap() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status GetMap(::grpc::ServerContext* /*context*/, const ::protobuf::NullRequest* /*request*/, ::protobuf::MessageOfMap* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestGetMap(::grpc::ServerContext* context, ::protobuf::NullRequest* request, ::grpc::ServerAsyncResponseWriter<::protobuf::MessageOfMap>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_Move : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_Move()
            {
                ::grpc::Service::MarkMethodAsync(3);
            }
            ~WithAsyncMethod_Move() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Move(::grpc::ServerContext* /*context*/, const ::protobuf::MoveMsg* /*request*/, ::protobuf::MoveRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestMove(::grpc::ServerContext* context, ::protobuf::MoveMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::MoveRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_Recover : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_Recover()
            {
                ::grpc::Service::MarkMethodAsync(4);
            }
            ~WithAsyncMethod_Recover() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::protobuf::RecoverMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestRecover(::grpc::ServerContext* context, ::protobuf::RecoverMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_Produce : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_Produce()
            {
                ::grpc::Service::MarkMethodAsync(5);
            }
            ~WithAsyncMethod_Produce() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Produce(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestProduce(::grpc::ServerContext* context, ::protobuf::IDMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_Rebuild : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_Rebuild()
            {
                ::grpc::Service::MarkMethodAsync(6);
            }
            ~WithAsyncMethod_Rebuild() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Rebuild(::grpc::ServerContext* /*context*/, const ::protobuf::ConstructMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestRebuild(::grpc::ServerContext* context, ::protobuf::ConstructMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_Construct : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_Construct()
            {
                ::grpc::Service::MarkMethodAsync(7);
            }
            ~WithAsyncMethod_Construct() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Construct(::grpc::ServerContext* /*context*/, const ::protobuf::ConstructMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestConstruct(::grpc::ServerContext* context, ::protobuf::ConstructMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_RepairHome : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_RepairHome()
            {
                ::grpc::Service::MarkMethodAsync(8);
            }
            ~WithAsyncMethod_RepairHome() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status RepairHome(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestRepairHome(::grpc::ServerContext* context, ::protobuf::IDMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_RepairWormhole : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_RepairWormhole()
            {
                ::grpc::Service::MarkMethodAsync(9);
            }
            ~WithAsyncMethod_RepairWormhole() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status RepairWormhole(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestRepairWormhole(::grpc::ServerContext* context, ::protobuf::IDMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_Attack : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_Attack()
            {
                ::grpc::Service::MarkMethodAsync(10);
            }
            ~WithAsyncMethod_Attack() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Attack(::grpc::ServerContext* /*context*/, const ::protobuf::AttackMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestAttack(::grpc::ServerContext* context, ::protobuf::AttackMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_Send : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_Send()
            {
                ::grpc::Service::MarkMethodAsync(11);
            }
            ~WithAsyncMethod_Send() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Send(::grpc::ServerContext* /*context*/, const ::protobuf::SendMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestSend(::grpc::ServerContext* context, ::protobuf::SendMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_InstallModule : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_InstallModule()
            {
                ::grpc::Service::MarkMethodAsync(12);
            }
            ~WithAsyncMethod_InstallModule() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status InstallModule(::grpc::ServerContext* /*context*/, const ::protobuf::InstallMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestInstallModule(::grpc::ServerContext* context, ::protobuf::InstallMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_Recycle : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_Recycle()
            {
                ::grpc::Service::MarkMethodAsync(13);
            }
            ~WithAsyncMethod_Recycle() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Recycle(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestRecycle(::grpc::ServerContext* context, ::protobuf::IDMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_BuildShip : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_BuildShip()
            {
                ::grpc::Service::MarkMethodAsync(14);
            }
            ~WithAsyncMethod_BuildShip() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status BuildShip(::grpc::ServerContext* /*context*/, const ::protobuf::BuildShipMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestBuildShip(::grpc::ServerContext* context, ::protobuf::BuildShipMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_BuildShipRID : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_BuildShipRID()
            {
                ::grpc::Service::MarkMethodAsync(15);
            }
            ~WithAsyncMethod_BuildShipRID() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status BuildShipRID(::grpc::ServerContext* /*context*/, const ::protobuf::BuildShipMsg* /*request*/, ::protobuf::BuildShipRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestBuildShipRID(::grpc::ServerContext* context, ::protobuf::BuildShipMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BuildShipRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithAsyncMethod_EndAllAction : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithAsyncMethod_EndAllAction()
            {
                ::grpc::Service::MarkMethodAsync(16);
            }
            ~WithAsyncMethod_EndAllAction() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status EndAllAction(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestEndAllAction(::grpc::ServerContext* context, ::protobuf::IDMsg* request, ::grpc::ServerAsyncResponseWriter<::protobuf::BoolRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        typedef WithAsyncMethod_TryConnection<WithAsyncMethod_AddPlayer<WithAsyncMethod_GetMap<WithAsyncMethod_Move<WithAsyncMethod_Recover<WithAsyncMethod_Produce<WithAsyncMethod_Rebuild<WithAsyncMethod_Construct<WithAsyncMethod_RepairHome<WithAsyncMethod_RepairWormhole<WithAsyncMethod_Attack<WithAsyncMethod_Send<WithAsyncMethod_InstallModule<WithAsyncMethod_Recycle<WithAsyncMethod_BuildShip<WithAsyncMethod_BuildShipRID<WithAsyncMethod_EndAllAction<Service>>>>>>>>>>>>>>>>> AsyncService;
        template<class BaseClass>
        class WithCallbackMethod_TryConnection : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_TryConnection()
            {
                ::grpc::Service::MarkMethodCallback(0, new ::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                          { return this->TryConnection(context, request, response); }));
            }
            void SetMessageAllocatorFor_TryConnection(
                ::grpc::MessageAllocator<::protobuf::IDMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_TryConnection() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status TryConnection(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* TryConnection(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_AddPlayer : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_AddPlayer()
            {
                ::grpc::Service::MarkMethodCallback(1, new ::grpc::internal::CallbackServerStreamingHandler<::protobuf::PlayerMsg, ::protobuf::MessageToClient>([this](::grpc::CallbackServerContext* context, const ::protobuf::PlayerMsg* request)
                                                                                                                                                                { return this->AddPlayer(context, request); }));
            }
            ~WithCallbackMethod_AddPlayer() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status AddPlayer(::grpc::ServerContext* /*context*/, const ::protobuf::PlayerMsg* /*request*/, ::grpc::ServerWriter<::protobuf::MessageToClient>* /*writer*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerWriteReactor<::protobuf::MessageToClient>* AddPlayer(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::PlayerMsg* /*request*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_GetMap : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_GetMap()
            {
                ::grpc::Service::MarkMethodCallback(2, new ::grpc::internal::CallbackUnaryHandler<::protobuf::NullRequest, ::protobuf::MessageOfMap>([this](::grpc::CallbackServerContext* context, const ::protobuf::NullRequest* request, ::protobuf::MessageOfMap* response)
                                                                                                                                                     { return this->GetMap(context, request, response); }));
            }
            void SetMessageAllocatorFor_GetMap(
                ::grpc::MessageAllocator<::protobuf::NullRequest, ::protobuf::MessageOfMap>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::NullRequest, ::protobuf::MessageOfMap>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_GetMap() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status GetMap(::grpc::ServerContext* /*context*/, const ::protobuf::NullRequest* /*request*/, ::protobuf::MessageOfMap* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* GetMap(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::NullRequest* /*request*/, ::protobuf::MessageOfMap* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_Move : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_Move()
            {
                ::grpc::Service::MarkMethodCallback(3, new ::grpc::internal::CallbackUnaryHandler<::protobuf::MoveMsg, ::protobuf::MoveRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::MoveMsg* request, ::protobuf::MoveRes* response)
                                                                                                                                            { return this->Move(context, request, response); }));
            }
            void SetMessageAllocatorFor_Move(
                ::grpc::MessageAllocator<::protobuf::MoveMsg, ::protobuf::MoveRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::MoveMsg, ::protobuf::MoveRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_Move() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Move(::grpc::ServerContext* /*context*/, const ::protobuf::MoveMsg* /*request*/, ::protobuf::MoveRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* Move(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::MoveMsg* /*request*/, ::protobuf::MoveRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_Recover : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_Recover()
            {
                ::grpc::Service::MarkMethodCallback(4, new ::grpc::internal::CallbackUnaryHandler<::protobuf::RecoverMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::RecoverMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                               { return this->Recover(context, request, response); }));
            }
            void SetMessageAllocatorFor_Recover(
                ::grpc::MessageAllocator<::protobuf::RecoverMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::RecoverMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_Recover() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::protobuf::RecoverMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* Recover(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::RecoverMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_Produce : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_Produce()
            {
                ::grpc::Service::MarkMethodCallback(5, new ::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                          { return this->Produce(context, request, response); }));
            }
            void SetMessageAllocatorFor_Produce(
                ::grpc::MessageAllocator<::protobuf::IDMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_Produce() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Produce(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* Produce(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_Rebuild : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_Rebuild()
            {
                ::grpc::Service::MarkMethodCallback(6, new ::grpc::internal::CallbackUnaryHandler<::protobuf::ConstructMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::ConstructMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                                 { return this->Rebuild(context, request, response); }));
            }
            void SetMessageAllocatorFor_Rebuild(
                ::grpc::MessageAllocator<::protobuf::ConstructMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::ConstructMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_Rebuild() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Rebuild(::grpc::ServerContext* /*context*/, const ::protobuf::ConstructMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* Rebuild(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::ConstructMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_Construct : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_Construct()
            {
                ::grpc::Service::MarkMethodCallback(7, new ::grpc::internal::CallbackUnaryHandler<::protobuf::ConstructMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::ConstructMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                                 { return this->Construct(context, request, response); }));
            }
            void SetMessageAllocatorFor_Construct(
                ::grpc::MessageAllocator<::protobuf::ConstructMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::ConstructMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_Construct() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Construct(::grpc::ServerContext* /*context*/, const ::protobuf::ConstructMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* Construct(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::ConstructMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_RepairHome : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_RepairHome()
            {
                ::grpc::Service::MarkMethodCallback(8, new ::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                          { return this->RepairHome(context, request, response); }));
            }
            void SetMessageAllocatorFor_RepairHome(
                ::grpc::MessageAllocator<::protobuf::IDMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_RepairHome() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status RepairHome(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* RepairHome(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_RepairWormhole : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_RepairWormhole()
            {
                ::grpc::Service::MarkMethodCallback(9, new ::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                          { return this->RepairWormhole(context, request, response); }));
            }
            void SetMessageAllocatorFor_RepairWormhole(
                ::grpc::MessageAllocator<::protobuf::IDMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_RepairWormhole() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status RepairWormhole(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* RepairWormhole(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_Attack : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_Attack()
            {
                ::grpc::Service::MarkMethodCallback(10, new ::grpc::internal::CallbackUnaryHandler<::protobuf::AttackMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::AttackMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                               { return this->Attack(context, request, response); }));
            }
            void SetMessageAllocatorFor_Attack(
                ::grpc::MessageAllocator<::protobuf::AttackMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::AttackMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_Attack() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Attack(::grpc::ServerContext* /*context*/, const ::protobuf::AttackMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* Attack(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::AttackMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_Send : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_Send()
            {
                ::grpc::Service::MarkMethodCallback(11, new ::grpc::internal::CallbackUnaryHandler<::protobuf::SendMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::SendMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                             { return this->Send(context, request, response); }));
            }
            void SetMessageAllocatorFor_Send(
                ::grpc::MessageAllocator<::protobuf::SendMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::SendMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_Send() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Send(::grpc::ServerContext* /*context*/, const ::protobuf::SendMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* Send(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::SendMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_InstallModule : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_InstallModule()
            {
                ::grpc::Service::MarkMethodCallback(12, new ::grpc::internal::CallbackUnaryHandler<::protobuf::InstallMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::InstallMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                                { return this->InstallModule(context, request, response); }));
            }
            void SetMessageAllocatorFor_InstallModule(
                ::grpc::MessageAllocator<::protobuf::InstallMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::InstallMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_InstallModule() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status InstallModule(::grpc::ServerContext* /*context*/, const ::protobuf::InstallMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* InstallModule(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::InstallMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_Recycle : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_Recycle()
            {
                ::grpc::Service::MarkMethodCallback(13, new ::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                           { return this->Recycle(context, request, response); }));
            }
            void SetMessageAllocatorFor_Recycle(
                ::grpc::MessageAllocator<::protobuf::IDMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_Recycle() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Recycle(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* Recycle(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_BuildShip : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_BuildShip()
            {
                ::grpc::Service::MarkMethodCallback(14, new ::grpc::internal::CallbackUnaryHandler<::protobuf::BuildShipMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::BuildShipMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                                  { return this->BuildShip(context, request, response); }));
            }
            void SetMessageAllocatorFor_BuildShip(
                ::grpc::MessageAllocator<::protobuf::BuildShipMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::BuildShipMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_BuildShip() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status BuildShip(::grpc::ServerContext* /*context*/, const ::protobuf::BuildShipMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* BuildShip(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::BuildShipMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_BuildShipRID : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_BuildShipRID()
            {
                ::grpc::Service::MarkMethodCallback(15, new ::grpc::internal::CallbackUnaryHandler<::protobuf::BuildShipMsg, ::protobuf::BuildShipRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::BuildShipMsg* request, ::protobuf::BuildShipRes* response)
                                                                                                                                                       { return this->BuildShipRID(context, request, response); }));
            }
            void SetMessageAllocatorFor_BuildShipRID(
                ::grpc::MessageAllocator<::protobuf::BuildShipMsg, ::protobuf::BuildShipRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::BuildShipMsg, ::protobuf::BuildShipRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_BuildShipRID() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status BuildShipRID(::grpc::ServerContext* /*context*/, const ::protobuf::BuildShipMsg* /*request*/, ::protobuf::BuildShipRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* BuildShipRID(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::BuildShipMsg* /*request*/, ::protobuf::BuildShipRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithCallbackMethod_EndAllAction : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithCallbackMethod_EndAllAction()
            {
                ::grpc::Service::MarkMethodCallback(16, new ::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::CallbackServerContext* context, const ::protobuf::IDMsg* request, ::protobuf::BoolRes* response)
                                                                                                                                           { return this->EndAllAction(context, request, response); }));
            }
            void SetMessageAllocatorFor_EndAllAction(
                ::grpc::MessageAllocator<::protobuf::IDMsg, ::protobuf::BoolRes>* allocator
            )
            {
                ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
                static_cast<::grpc::internal::CallbackUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>*>(handler)
                    ->SetMessageAllocator(allocator);
            }
            ~WithCallbackMethod_EndAllAction() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status EndAllAction(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* EndAllAction(
                ::grpc::CallbackServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/
            )
            {
                return nullptr;
            }
        };
        typedef WithCallbackMethod_TryConnection<WithCallbackMethod_AddPlayer<WithCallbackMethod_GetMap<WithCallbackMethod_Move<WithCallbackMethod_Recover<WithCallbackMethod_Produce<WithCallbackMethod_Rebuild<WithCallbackMethod_Construct<WithCallbackMethod_RepairHome<WithCallbackMethod_RepairWormhole<WithCallbackMethod_Attack<WithCallbackMethod_Send<WithCallbackMethod_InstallModule<WithCallbackMethod_Recycle<WithCallbackMethod_BuildShip<WithCallbackMethod_BuildShipRID<WithCallbackMethod_EndAllAction<Service>>>>>>>>>>>>>>>>> CallbackService;
        typedef CallbackService ExperimentalCallbackService;
        template<class BaseClass>
        class WithGenericMethod_TryConnection : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_TryConnection()
            {
                ::grpc::Service::MarkMethodGeneric(0);
            }
            ~WithGenericMethod_TryConnection() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status TryConnection(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_AddPlayer : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_AddPlayer()
            {
                ::grpc::Service::MarkMethodGeneric(1);
            }
            ~WithGenericMethod_AddPlayer() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status AddPlayer(::grpc::ServerContext* /*context*/, const ::protobuf::PlayerMsg* /*request*/, ::grpc::ServerWriter<::protobuf::MessageToClient>* /*writer*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_GetMap : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_GetMap()
            {
                ::grpc::Service::MarkMethodGeneric(2);
            }
            ~WithGenericMethod_GetMap() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status GetMap(::grpc::ServerContext* /*context*/, const ::protobuf::NullRequest* /*request*/, ::protobuf::MessageOfMap* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_Move : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_Move()
            {
                ::grpc::Service::MarkMethodGeneric(3);
            }
            ~WithGenericMethod_Move() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Move(::grpc::ServerContext* /*context*/, const ::protobuf::MoveMsg* /*request*/, ::protobuf::MoveRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_Recover : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_Recover()
            {
                ::grpc::Service::MarkMethodGeneric(4);
            }
            ~WithGenericMethod_Recover() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::protobuf::RecoverMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_Produce : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_Produce()
            {
                ::grpc::Service::MarkMethodGeneric(5);
            }
            ~WithGenericMethod_Produce() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Produce(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_Rebuild : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_Rebuild()
            {
                ::grpc::Service::MarkMethodGeneric(6);
            }
            ~WithGenericMethod_Rebuild() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Rebuild(::grpc::ServerContext* /*context*/, const ::protobuf::ConstructMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_Construct : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_Construct()
            {
                ::grpc::Service::MarkMethodGeneric(7);
            }
            ~WithGenericMethod_Construct() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Construct(::grpc::ServerContext* /*context*/, const ::protobuf::ConstructMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_RepairHome : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_RepairHome()
            {
                ::grpc::Service::MarkMethodGeneric(8);
            }
            ~WithGenericMethod_RepairHome() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status RepairHome(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_RepairWormhole : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_RepairWormhole()
            {
                ::grpc::Service::MarkMethodGeneric(9);
            }
            ~WithGenericMethod_RepairWormhole() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status RepairWormhole(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_Attack : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_Attack()
            {
                ::grpc::Service::MarkMethodGeneric(10);
            }
            ~WithGenericMethod_Attack() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Attack(::grpc::ServerContext* /*context*/, const ::protobuf::AttackMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_Send : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_Send()
            {
                ::grpc::Service::MarkMethodGeneric(11);
            }
            ~WithGenericMethod_Send() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Send(::grpc::ServerContext* /*context*/, const ::protobuf::SendMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_InstallModule : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_InstallModule()
            {
                ::grpc::Service::MarkMethodGeneric(12);
            }
            ~WithGenericMethod_InstallModule() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status InstallModule(::grpc::ServerContext* /*context*/, const ::protobuf::InstallMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_Recycle : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_Recycle()
            {
                ::grpc::Service::MarkMethodGeneric(13);
            }
            ~WithGenericMethod_Recycle() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Recycle(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_BuildShip : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_BuildShip()
            {
                ::grpc::Service::MarkMethodGeneric(14);
            }
            ~WithGenericMethod_BuildShip() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status BuildShip(::grpc::ServerContext* /*context*/, const ::protobuf::BuildShipMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_BuildShipRID : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_BuildShipRID()
            {
                ::grpc::Service::MarkMethodGeneric(15);
            }
            ~WithGenericMethod_BuildShipRID() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status BuildShipRID(::grpc::ServerContext* /*context*/, const ::protobuf::BuildShipMsg* /*request*/, ::protobuf::BuildShipRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithGenericMethod_EndAllAction : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithGenericMethod_EndAllAction()
            {
                ::grpc::Service::MarkMethodGeneric(16);
            }
            ~WithGenericMethod_EndAllAction() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status EndAllAction(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
        };
        template<class BaseClass>
        class WithRawMethod_TryConnection : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_TryConnection()
            {
                ::grpc::Service::MarkMethodRaw(0);
            }
            ~WithRawMethod_TryConnection() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status TryConnection(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestTryConnection(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_AddPlayer : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_AddPlayer()
            {
                ::grpc::Service::MarkMethodRaw(1);
            }
            ~WithRawMethod_AddPlayer() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status AddPlayer(::grpc::ServerContext* /*context*/, const ::protobuf::PlayerMsg* /*request*/, ::grpc::ServerWriter<::protobuf::MessageToClient>* /*writer*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestAddPlayer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter<::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_GetMap : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_GetMap()
            {
                ::grpc::Service::MarkMethodRaw(2);
            }
            ~WithRawMethod_GetMap() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status GetMap(::grpc::ServerContext* /*context*/, const ::protobuf::NullRequest* /*request*/, ::protobuf::MessageOfMap* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestGetMap(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_Move : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_Move()
            {
                ::grpc::Service::MarkMethodRaw(3);
            }
            ~WithRawMethod_Move() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Move(::grpc::ServerContext* /*context*/, const ::protobuf::MoveMsg* /*request*/, ::protobuf::MoveRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestMove(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_Recover : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_Recover()
            {
                ::grpc::Service::MarkMethodRaw(4);
            }
            ~WithRawMethod_Recover() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::protobuf::RecoverMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestRecover(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_Produce : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_Produce()
            {
                ::grpc::Service::MarkMethodRaw(5);
            }
            ~WithRawMethod_Produce() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Produce(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestProduce(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_Rebuild : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_Rebuild()
            {
                ::grpc::Service::MarkMethodRaw(6);
            }
            ~WithRawMethod_Rebuild() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Rebuild(::grpc::ServerContext* /*context*/, const ::protobuf::ConstructMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestRebuild(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_Construct : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_Construct()
            {
                ::grpc::Service::MarkMethodRaw(7);
            }
            ~WithRawMethod_Construct() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Construct(::grpc::ServerContext* /*context*/, const ::protobuf::ConstructMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestConstruct(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_RepairHome : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_RepairHome()
            {
                ::grpc::Service::MarkMethodRaw(8);
            }
            ~WithRawMethod_RepairHome() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status RepairHome(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestRepairHome(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_RepairWormhole : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_RepairWormhole()
            {
                ::grpc::Service::MarkMethodRaw(9);
            }
            ~WithRawMethod_RepairWormhole() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status RepairWormhole(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestRepairWormhole(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_Attack : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_Attack()
            {
                ::grpc::Service::MarkMethodRaw(10);
            }
            ~WithRawMethod_Attack() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Attack(::grpc::ServerContext* /*context*/, const ::protobuf::AttackMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestAttack(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_Send : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_Send()
            {
                ::grpc::Service::MarkMethodRaw(11);
            }
            ~WithRawMethod_Send() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Send(::grpc::ServerContext* /*context*/, const ::protobuf::SendMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestSend(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_InstallModule : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_InstallModule()
            {
                ::grpc::Service::MarkMethodRaw(12);
            }
            ~WithRawMethod_InstallModule() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status InstallModule(::grpc::ServerContext* /*context*/, const ::protobuf::InstallMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestInstallModule(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_Recycle : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_Recycle()
            {
                ::grpc::Service::MarkMethodRaw(13);
            }
            ~WithRawMethod_Recycle() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Recycle(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestRecycle(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_BuildShip : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_BuildShip()
            {
                ::grpc::Service::MarkMethodRaw(14);
            }
            ~WithRawMethod_BuildShip() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status BuildShip(::grpc::ServerContext* /*context*/, const ::protobuf::BuildShipMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestBuildShip(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_BuildShipRID : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_BuildShipRID()
            {
                ::grpc::Service::MarkMethodRaw(15);
            }
            ~WithRawMethod_BuildShipRID() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status BuildShipRID(::grpc::ServerContext* /*context*/, const ::protobuf::BuildShipMsg* /*request*/, ::protobuf::BuildShipRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestBuildShipRID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawMethod_EndAllAction : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawMethod_EndAllAction()
            {
                ::grpc::Service::MarkMethodRaw(16);
            }
            ~WithRawMethod_EndAllAction() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status EndAllAction(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            void RequestEndAllAction(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
            {
                ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_TryConnection : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_TryConnection()
            {
                ::grpc::Service::MarkMethodRawCallback(0, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                             { return this->TryConnection(context, request, response); }));
            }
            ~WithRawCallbackMethod_TryConnection() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status TryConnection(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* TryConnection(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_AddPlayer : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_AddPlayer()
            {
                ::grpc::Service::MarkMethodRawCallback(1, new ::grpc::internal::CallbackServerStreamingHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request)
                                                                                                                                                       { return this->AddPlayer(context, request); }));
            }
            ~WithRawCallbackMethod_AddPlayer() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status AddPlayer(::grpc::ServerContext* /*context*/, const ::protobuf::PlayerMsg* /*request*/, ::grpc::ServerWriter<::protobuf::MessageToClient>* /*writer*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerWriteReactor<::grpc::ByteBuffer>* AddPlayer(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_GetMap : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_GetMap()
            {
                ::grpc::Service::MarkMethodRawCallback(2, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                             { return this->GetMap(context, request, response); }));
            }
            ~WithRawCallbackMethod_GetMap() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status GetMap(::grpc::ServerContext* /*context*/, const ::protobuf::NullRequest* /*request*/, ::protobuf::MessageOfMap* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* GetMap(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_Move : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_Move()
            {
                ::grpc::Service::MarkMethodRawCallback(3, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                             { return this->Move(context, request, response); }));
            }
            ~WithRawCallbackMethod_Move() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Move(::grpc::ServerContext* /*context*/, const ::protobuf::MoveMsg* /*request*/, ::protobuf::MoveRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* Move(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_Recover : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_Recover()
            {
                ::grpc::Service::MarkMethodRawCallback(4, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                             { return this->Recover(context, request, response); }));
            }
            ~WithRawCallbackMethod_Recover() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::protobuf::RecoverMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* Recover(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_Produce : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_Produce()
            {
                ::grpc::Service::MarkMethodRawCallback(5, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                             { return this->Produce(context, request, response); }));
            }
            ~WithRawCallbackMethod_Produce() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Produce(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* Produce(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_Rebuild : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_Rebuild()
            {
                ::grpc::Service::MarkMethodRawCallback(6, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                             { return this->Rebuild(context, request, response); }));
            }
            ~WithRawCallbackMethod_Rebuild() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Rebuild(::grpc::ServerContext* /*context*/, const ::protobuf::ConstructMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* Rebuild(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_Construct : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_Construct()
            {
                ::grpc::Service::MarkMethodRawCallback(7, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                             { return this->Construct(context, request, response); }));
            }
            ~WithRawCallbackMethod_Construct() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Construct(::grpc::ServerContext* /*context*/, const ::protobuf::ConstructMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* Construct(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_RepairHome : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_RepairHome()
            {
                ::grpc::Service::MarkMethodRawCallback(8, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                             { return this->RepairHome(context, request, response); }));
            }
            ~WithRawCallbackMethod_RepairHome() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status RepairHome(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* RepairHome(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_RepairWormhole : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_RepairWormhole()
            {
                ::grpc::Service::MarkMethodRawCallback(9, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                             { return this->RepairWormhole(context, request, response); }));
            }
            ~WithRawCallbackMethod_RepairWormhole() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status RepairWormhole(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* RepairWormhole(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_Attack : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_Attack()
            {
                ::grpc::Service::MarkMethodRawCallback(10, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                              { return this->Attack(context, request, response); }));
            }
            ~WithRawCallbackMethod_Attack() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Attack(::grpc::ServerContext* /*context*/, const ::protobuf::AttackMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* Attack(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_Send : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_Send()
            {
                ::grpc::Service::MarkMethodRawCallback(11, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                              { return this->Send(context, request, response); }));
            }
            ~WithRawCallbackMethod_Send() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Send(::grpc::ServerContext* /*context*/, const ::protobuf::SendMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* Send(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_InstallModule : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_InstallModule()
            {
                ::grpc::Service::MarkMethodRawCallback(12, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                              { return this->InstallModule(context, request, response); }));
            }
            ~WithRawCallbackMethod_InstallModule() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status InstallModule(::grpc::ServerContext* /*context*/, const ::protobuf::InstallMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* InstallModule(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_Recycle : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_Recycle()
            {
                ::grpc::Service::MarkMethodRawCallback(13, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                              { return this->Recycle(context, request, response); }));
            }
            ~WithRawCallbackMethod_Recycle() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status Recycle(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* Recycle(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_BuildShip : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_BuildShip()
            {
                ::grpc::Service::MarkMethodRawCallback(14, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                              { return this->BuildShip(context, request, response); }));
            }
            ~WithRawCallbackMethod_BuildShip() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status BuildShip(::grpc::ServerContext* /*context*/, const ::protobuf::BuildShipMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* BuildShip(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_BuildShipRID : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_BuildShipRID()
            {
                ::grpc::Service::MarkMethodRawCallback(15, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                              { return this->BuildShipRID(context, request, response); }));
            }
            ~WithRawCallbackMethod_BuildShipRID() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status BuildShipRID(::grpc::ServerContext* /*context*/, const ::protobuf::BuildShipMsg* /*request*/, ::protobuf::BuildShipRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* BuildShipRID(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithRawCallbackMethod_EndAllAction : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithRawCallbackMethod_EndAllAction()
            {
                ::grpc::Service::MarkMethodRawCallback(16, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>([this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response)
                                                                                                                                              { return this->EndAllAction(context, request, response); }));
            }
            ~WithRawCallbackMethod_EndAllAction() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable synchronous version of this method
            ::grpc::Status EndAllAction(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            virtual ::grpc::ServerUnaryReactor* EndAllAction(
                ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/
            )
            {
                return nullptr;
            }
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_TryConnection : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_TryConnection()
            {
                ::grpc::Service::MarkMethodStreamed(0, new ::grpc::internal::StreamedUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                          { return this->StreamedTryConnection(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_TryConnection() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status TryConnection(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedTryConnection(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_GetMap : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_GetMap()
            {
                ::grpc::Service::MarkMethodStreamed(2, new ::grpc::internal::StreamedUnaryHandler<::protobuf::NullRequest, ::protobuf::MessageOfMap>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::NullRequest, ::protobuf::MessageOfMap>* streamer)
                                                                                                                                                     { return this->StreamedGetMap(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_GetMap() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status GetMap(::grpc::ServerContext* /*context*/, const ::protobuf::NullRequest* /*request*/, ::protobuf::MessageOfMap* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedGetMap(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::NullRequest, ::protobuf::MessageOfMap>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_Move : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_Move()
            {
                ::grpc::Service::MarkMethodStreamed(3, new ::grpc::internal::StreamedUnaryHandler<::protobuf::MoveMsg, ::protobuf::MoveRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::MoveMsg, ::protobuf::MoveRes>* streamer)
                                                                                                                                            { return this->StreamedMove(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_Move() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status Move(::grpc::ServerContext* /*context*/, const ::protobuf::MoveMsg* /*request*/, ::protobuf::MoveRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedMove(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::MoveMsg, ::protobuf::MoveRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_Recover : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_Recover()
            {
                ::grpc::Service::MarkMethodStreamed(4, new ::grpc::internal::StreamedUnaryHandler<::protobuf::RecoverMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::RecoverMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                               { return this->StreamedRecover(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_Recover() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status Recover(::grpc::ServerContext* /*context*/, const ::protobuf::RecoverMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedRecover(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::RecoverMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_Produce : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_Produce()
            {
                ::grpc::Service::MarkMethodStreamed(5, new ::grpc::internal::StreamedUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                          { return this->StreamedProduce(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_Produce() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status Produce(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedProduce(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_Rebuild : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_Rebuild()
            {
                ::grpc::Service::MarkMethodStreamed(6, new ::grpc::internal::StreamedUnaryHandler<::protobuf::ConstructMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::ConstructMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                                 { return this->StreamedRebuild(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_Rebuild() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status Rebuild(::grpc::ServerContext* /*context*/, const ::protobuf::ConstructMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedRebuild(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::ConstructMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_Construct : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_Construct()
            {
                ::grpc::Service::MarkMethodStreamed(7, new ::grpc::internal::StreamedUnaryHandler<::protobuf::ConstructMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::ConstructMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                                 { return this->StreamedConstruct(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_Construct() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status Construct(::grpc::ServerContext* /*context*/, const ::protobuf::ConstructMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedConstruct(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::ConstructMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_RepairHome : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_RepairHome()
            {
                ::grpc::Service::MarkMethodStreamed(8, new ::grpc::internal::StreamedUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                          { return this->StreamedRepairHome(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_RepairHome() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status RepairHome(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedRepairHome(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_RepairWormhole : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_RepairWormhole()
            {
                ::grpc::Service::MarkMethodStreamed(9, new ::grpc::internal::StreamedUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                          { return this->StreamedRepairWormhole(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_RepairWormhole() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status RepairWormhole(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedRepairWormhole(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_Attack : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_Attack()
            {
                ::grpc::Service::MarkMethodStreamed(10, new ::grpc::internal::StreamedUnaryHandler<::protobuf::AttackMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::AttackMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                               { return this->StreamedAttack(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_Attack() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status Attack(::grpc::ServerContext* /*context*/, const ::protobuf::AttackMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedAttack(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::AttackMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_Send : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_Send()
            {
                ::grpc::Service::MarkMethodStreamed(11, new ::grpc::internal::StreamedUnaryHandler<::protobuf::SendMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::SendMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                             { return this->StreamedSend(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_Send() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status Send(::grpc::ServerContext* /*context*/, const ::protobuf::SendMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedSend(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::SendMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_InstallModule : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_InstallModule()
            {
                ::grpc::Service::MarkMethodStreamed(12, new ::grpc::internal::StreamedUnaryHandler<::protobuf::InstallMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::InstallMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                                { return this->StreamedInstallModule(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_InstallModule() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status InstallModule(::grpc::ServerContext* /*context*/, const ::protobuf::InstallMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedInstallModule(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::InstallMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_Recycle : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_Recycle()
            {
                ::grpc::Service::MarkMethodStreamed(13, new ::grpc::internal::StreamedUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                           { return this->StreamedRecycle(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_Recycle() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status Recycle(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedRecycle(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_BuildShip : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_BuildShip()
            {
                ::grpc::Service::MarkMethodStreamed(14, new ::grpc::internal::StreamedUnaryHandler<::protobuf::BuildShipMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::BuildShipMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                                  { return this->StreamedBuildShip(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_BuildShip() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status BuildShip(::grpc::ServerContext* /*context*/, const ::protobuf::BuildShipMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedBuildShip(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::BuildShipMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_BuildShipRID : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_BuildShipRID()
            {
                ::grpc::Service::MarkMethodStreamed(15, new ::grpc::internal::StreamedUnaryHandler<::protobuf::BuildShipMsg, ::protobuf::BuildShipRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::BuildShipMsg, ::protobuf::BuildShipRes>* streamer)
                                                                                                                                                       { return this->StreamedBuildShipRID(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_BuildShipRID() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status BuildShipRID(::grpc::ServerContext* /*context*/, const ::protobuf::BuildShipMsg* /*request*/, ::protobuf::BuildShipRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedBuildShipRID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::BuildShipMsg, ::protobuf::BuildShipRes>* server_unary_streamer) = 0;
        };
        template<class BaseClass>
        class WithStreamedUnaryMethod_EndAllAction : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithStreamedUnaryMethod_EndAllAction()
            {
                ::grpc::Service::MarkMethodStreamed(16, new ::grpc::internal::StreamedUnaryHandler<::protobuf::IDMsg, ::protobuf::BoolRes>([this](::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* streamer)
                                                                                                                                           { return this->StreamedEndAllAction(context, streamer); }));
            }
            ~WithStreamedUnaryMethod_EndAllAction() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status EndAllAction(::grpc::ServerContext* /*context*/, const ::protobuf::IDMsg* /*request*/, ::protobuf::BoolRes* /*response*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with streamed unary
            virtual ::grpc::Status StreamedEndAllAction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer<::protobuf::IDMsg, ::protobuf::BoolRes>* server_unary_streamer) = 0;
        };
        typedef WithStreamedUnaryMethod_TryConnection<WithStreamedUnaryMethod_GetMap<WithStreamedUnaryMethod_Move<WithStreamedUnaryMethod_Recover<WithStreamedUnaryMethod_Produce<WithStreamedUnaryMethod_Rebuild<WithStreamedUnaryMethod_Construct<WithStreamedUnaryMethod_RepairHome<WithStreamedUnaryMethod_RepairWormhole<WithStreamedUnaryMethod_Attack<WithStreamedUnaryMethod_Send<WithStreamedUnaryMethod_InstallModule<WithStreamedUnaryMethod_Recycle<WithStreamedUnaryMethod_BuildShip<WithStreamedUnaryMethod_BuildShipRID<WithStreamedUnaryMethod_EndAllAction<Service>>>>>>>>>>>>>>>> StreamedUnaryService;
        template<class BaseClass>
        class WithSplitStreamingMethod_AddPlayer : public BaseClass
        {
        private:
            void BaseClassMustBeDerivedFromService(const Service* /*service*/)
            {
            }

        public:
            WithSplitStreamingMethod_AddPlayer()
            {
                ::grpc::Service::MarkMethodStreamed(1, new ::grpc::internal::SplitServerStreamingHandler<::protobuf::PlayerMsg, ::protobuf::MessageToClient>([this](::grpc::ServerContext* context, ::grpc::ServerSplitStreamer<::protobuf::PlayerMsg, ::protobuf::MessageToClient>* streamer)
                                                                                                                                                             { return this->StreamedAddPlayer(context, streamer); }));
            }
            ~WithSplitStreamingMethod_AddPlayer() override
            {
                BaseClassMustBeDerivedFromService(this);
            }
            // disable regular version of this method
            ::grpc::Status AddPlayer(::grpc::ServerContext* /*context*/, const ::protobuf::PlayerMsg* /*request*/, ::grpc::ServerWriter<::protobuf::MessageToClient>* /*writer*/) override
            {
                abort();
                return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
            }
            // replace default version of method with split streamed
            virtual ::grpc::Status StreamedAddPlayer(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer<::protobuf::PlayerMsg, ::protobuf::MessageToClient>* server_split_streamer) = 0;
        };
        typedef WithSplitStreamingMethod_AddPlayer<Service> SplitStreamedService;
        typedef WithStreamedUnaryMethod_TryConnection<WithSplitStreamingMethod_AddPlayer<WithStreamedUnaryMethod_GetMap<WithStreamedUnaryMethod_Move<WithStreamedUnaryMethod_Recover<WithStreamedUnaryMethod_Produce<WithStreamedUnaryMethod_Rebuild<WithStreamedUnaryMethod_Construct<WithStreamedUnaryMethod_RepairHome<WithStreamedUnaryMethod_RepairWormhole<WithStreamedUnaryMethod_Attack<WithStreamedUnaryMethod_Send<WithStreamedUnaryMethod_InstallModule<WithStreamedUnaryMethod_Recycle<WithStreamedUnaryMethod_BuildShip<WithStreamedUnaryMethod_BuildShipRID<WithStreamedUnaryMethod_EndAllAction<Service>>>>>>>>>>>>>>>>> StreamedService;
    };

}  // namespace protobuf

#endif  // GRPC_Services_2eproto__INCLUDED
